Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для швидкого зберігання та доставання аналізів та інших документів

Студент гр. ПЗПІ-21-5		 __________________ Сивуха Я.Є.
     (підпис)
Керівник роботи 			___________________ ст.викл. Сокорчук І.П.
     (підпис) 
     Роботу захищено «__»_________2024 р.
     з оцінкою _________________________ 
     
Комісія: 				___________________ доц. Лещинський В.О. 
     (підпис)
     ___________________ доц. Лещинська І.О. 
     (підпис)
     ___________________ ст.викл. Сокорчук І.П.
     (підпис)
     

Харків
2024 р.
Харківський національний університет радіоелектроніки 

Факультет комп’ютерних наук Кафедра програмної інженерії	          
Спеціальність 121 – Інженерія програмного забезпечення		          
Курс                     3                     Семестр 	                  6 		          
Навчальна дисципліна Архітектура програмного забезпечення	          

ЗАВДАННЯ 
НА КУРСОВУ РОБОТИ СТУДЕНТОВІ  
                                  Сивусі Ярославу Євгеновичу				           
1. Тема проекту: Програмна система для швидкого зберігання та доставання аналізів та інших документів «DocMe»
2. Термін узгодження завдання з лабораторних робіт «_31_»_березня_ 2024 р.
3. Термін здачі завдання з лабораторних робіт «  10   »       червня        2024 р.  
4. Вихідні дані до проекту: в програмній системі передбачити: додавання, редагування та видалення документів, завантаження їх на пристрій користувача, використовувати OC Windows 10, середовище розробки VS Code, Android Studio
5. Зміст звітів з лабораторних робіт (перелік питань, що належить розробити):
аналіз предметної області, постановка задачі, проектування бази даних, архітектура програмної системи, опис програмної системи, висновки, перелік посилань, додатки
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): ER-діаграма бази даних, Логічна схема бази даних, Діаграма розгортання серверної частини програмної системи, Діаграма розгортання серверної частини програмної системи, Діаграма прецедентів клієнтської частини програмної системи, Діаграма пакетів клієнтської частини програмної системи, Діаграма компонентів клієнтської частини програмної системи, Діаграма взаємодії клієнтської частини програмної системи, Діаграма взаємодії клієнтської частини програмної системи, Діаграма прецедентів мобільної програмної частини, Діаграма пакетів мобільної програмної частини, Діаграма пакетів мобільної програмної частини, Діаграма пакетів мобільної програмної частини, Результат виконання команди «npx docker:up», Результат виконання команди «npx docker:up», Наповнений файл ./.env.example, Результат запуску веб-частини, і місце знаходження посилання, Сторінка реєстрації, Сторінка входу, Сторінка профілю, Повідомлення о оновленні профіля, Меню на якому можливо змінити локалізацію, Сторінка профілю з зміненою мовою інтерфейсу, Сторінка документів, Сторінка додавання документів, Сторінка додавання документів, Сторінка додавання документів, Сторінка додавання документів, Повідомлення від браузера о завантаженому документі, Локально завантажений документ, Локально завантажений документ, Сторінка реєстрування та додавання себе до організації, Сторінка документів організації, Сторінка керування користувачами системи, Адміністративна сторінка організацій, Адміністративна сторінка документів, Результат перевірки на плагіат, Діаграма прецедентів 

КАЛЕНДАРНИЙ ПЛАН
№
Основні етапи виконання проекту в рамках лабораторних робіт
Термін виконання
етапів
Примітка
1
Функціональна специфікація 
програмного проекту
31.03.24

2
Проектування програмного 
проекту
30.04.24

3
Кодування програмного проекту
20.05.24

4
Оформлення пояснювальної 
записки
31.05.24

5
Захист курсової роботи
08.06.24


     Дата видачі завдання «__25__»____ березня____2023 р.  
     Керівник 				 ______________ доц. Лещинський В.О.
      (підпис)  
     Завдання прийняв до виконання 
ст.гр. ПЗПІ-21-5			 _____________		 _Сивуха Я.Є._ 
               (підпис)


РЕФЕРАТ
     
     
     Пояснювальна записка до курсової роботи: 81 с., 38 рис., 2 табл., 5 додатків, 6 джерел.
     МЕДЕЦИНА, ДОКУМЕНТИ, АНАЛІЗИ, КОРИСТУВАЧ, ПРОГРАМНА СИСТЕМА, АДМІНІСТРАТОР, ПРИСТРІЙ
     
     В цій курсовій роботі за об'єкт дослідження виступає індустрія документообігу. Більш точніше електронну версію цієї галузі. На сьогодні питання зручного зберігання документів і медичних аналізів є досить важливим. 
     Метою проекту є розробка програмної системи, яка забезпечує можливість зберігання, завантаження з та на пристрій, керування цими документами, та можливість додавання зовнішніх організації які зможуть робити ці дії у автоматизованому форматі за допомогою зовнішнього інтерфейсу користування цієї програмної системи.
     Розробка відбувається за допомогою таких технологій як: React.Js (застосунок) та Nest.js (сервер) які базуються на мові програмування JavaScript. Для полегшення написання та підтримки якість вже написаного коду, буде використовуватися мова як верхній шар над JavaScript під назвою TypeScript яка додає підтримку типів. База даних PostgreSQL. Та мобільний додаток написаний на мові Kotlin.
     Як результат роботи, було розроблено систему для зберігання та керування медичними та звичайними документами. Програмна система складається з веб застосунку, серверної частини та мобільного додатку.


ЗМІСТ
     
     
ВСТУП	8
АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	9
1.1 Бізнес вимоги	9
1.1.1 Бізнес-можливості	9
1.1.2 Бізнес-цілі та критерії успіху	10
1.1.3 Потреби клієнтів або ринку	11
1.1.4 Бізнес ризики	12
1.2 Концепція рішення	13
1.2.1 Окреслення концепції	13
1.2.2 Головна функціональність	14
1.2.3 Припущення та залежності	15
1.3 Рамки та обмеження проекту	15
1.3.1 Рамки первинного випуску	15
1.3.2 Рамки наступних випусків	17
1.3.3 Обмеження та винятки	19
1.4 Бізнес-контекст	20
1.4.1 Профілі зацікавлених сторін	20
1.4.2 Пріоритети проекту	21
1.4.3 Робоче середовище	21
2 ПОСТАНОВКА ЗАДАЧІ	23
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ	24
3.1 Побудова ER-діаграми	24
3.2 Побудова логічної моделі бази даних на основі ER-діаграми	25
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ	29
4.1 Архітектура серверної частини	29
4.2 Архітектура Веб частини	33
4.3 Архітектура мобільного додатку	38
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ	43
5.1 Виклик і завантаження	43
5.2 Призначення і логічна структура	46
5.3 Опис програмної реалізації	48
ВИСНОВКИ	58
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	59
ДОДАТОК А	60
ДОДАТОК Б	61
ДОДАТОК В	62
ДОДАТОК Г	67
ДОДАТОК Д	75


ВСТУП


     З плином часу якість інтернет-зв'язку та технологій постійно поліпшується, що відображається на якості нашого життя. Проте, люди часто не починають пильнувати за своїм здоров'ям, доки це не стає вимушеною дією. З розвитком технологій зростає як кількість доступних аналізів, так і спеціалістів, проте нових способів передавати інформацію (рецепти, аналізи, результати) значно менше відносно них.
     Це призводить до того, що багато людей змушені використовувати застарілі записні книжки, які швидко переповнюються, або просто носити всі документи в одній папці, що також не є зручним рішенням. Причиною цього є застаріла система яка не встигає розвиватися з плином часу. Ця стара система звикла використовувати тільки застрілі способи передачі інформації. 
     Для вирішення цієї проблеми можливо створити програмну систему, яка допоможе зберігати, організовувати та швидко знаходити необхідні дані та документи. Вона має бути зручною і зрозумілою для всіх можливих користувачів. І також мати зручну інтеграцію для вже існуючих систем. Така система могла б включати в себе функції автоматичного сортування, можливість зберігання різних типів файлів та швидкого доступу до них через інтерфейс, що призначений для користувача. 
     Також з часом ця система може бути розвинена не тільки для зберігання медичних документів, а і звичайних. Та ще з часом може бути розвинений і не тільки для простого зберігання.
     

АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес вимоги
1.1.1 Бізнес-можливості


     Найближчими аналогами такої системи можуть бути інші платформи, які використовують різні технології для залучення аудиторії. Прикладами є «M.E. doc» «Дія» та «DocuSign».
     "M.E. Doc": Це програмна система, що використовується для електронного обміну даними між користувачами, головна ідея полягає в тому щоб легко передати усілякі документи між аккаунтами користувачів, також мають інтеграцію с гугл поштою, і зручним АПІ для використання. Але пересилання документів не головна функціональність, також ця система може вести облік фінансів, складати звітність для податкових та фінансових органів, а також автоматизацію багатьох процесів, пов'язаних з фінансовою діяльністю підприємств. Крім того, M.E. Doc надає послуги з консультацій та підтримки користувачів з питань використання їх програмного забезпечення.
     "Дія": Ця програмна система призначена для зручного зберігання та отримування державних документів. В ній ти не маєш можливості зберігати будь-які документи. Але ця система котується державою. Вона не має вбудованої інтеграції з іншими системами, і тільки працює як одинична система з замкнутим доступом.
     "DocuSign": Ця програмна система розроблена для підписання онлайн документів та контрактів, ця система має обсяг по всій Європі, і дуже популярною системою для цих цілей.
     Проаналізувавши аналоги та схожі системи можливо зрозуміти що всі конкуренти не на пряму направлені на медичні документи та зручне користування ними. Поки «Дія» тільки дозволяє переглядати документи до яких тобі надає доступ держава, і не надає можливість самому їх додавати та редагувати їх данні. «M.E. doc» має непотрібну функціональність бухгалтерій, але має можливість підписувати документи, і це є дуже зручним, тому така можливість може також бути додана при розвитку нашої програмної системи. А «DocuSign» використовують тільки для підписів документів. Тому можливо прийти до висновку що, не буде конкуренції з іншими системами. 
     Моделлю прибутку у нашої системи передбачає отримання грошей від двох видів користувачів. Обидва види з яких будуть користуватися підпискою. Для компаній буде можливим тільки користуванням сервісу тільки через неї. Поки звичайні користувачі будуть мати можливість також користуватися безплатною версією яка матиме рекламу.
     
     
1.1.2 Бізнес-цілі та критерії успіху


     БЦ-1: Розширити географічне охоплення бізнесу:
         1. Розширити можливості проекту працювати що найменшу у трьох близько розташованих країнах;
         2. Встановити бізнес відносини з регіональними лікарнями та шпиталями, а також іншими не державними медичними установами.
     БЦ-2: Залучення нових клієнтів:
         1. Залучити щонайменше 30 нових клієнтів;
         2. Розширити взнаваємість бренду за допомогою реклами та активного маркетингу що найменше чим на 20%.
     БЦ-3: Розширення функціональності сервісу:
         1. Додавання більшої кількості мов користування;
         2. Розвинення ідеї та функціоналу пристроїв;
         3. Розвинення функціоналу проекту для використання онлайн.
     КУ-1: Рівень задоволеності клієнтів не менше 90%.
     КУ-2: Укласти угоди на користування сервісом щонайменше з 15 клієнтами.
     КУ-3: Забезпечити щонайменше 90% працюючих пристроїв які будуть безперебійно працювати.
     КУ-4: Запровадити не менше чотирьох нових функцій в системі протягом першого року використання продукту.


1.1.3 Потреби клієнтів або ринку


     Цей проект відповідає на потреби клієнтів і ринкових сегментів, які зацікавлені в зручному збереженні передачі та перегляданні їхніх документи.  
Так як немає сервісів які спрямовані саме на такі потреби, це сервіс буде добре сприйняти. Прямі приклади: 
     1. Іншим бізнесам: Система буде направленню на легкий взаємо зв'язок для інших система (зручний інтерфейс зовнішнього використання) за допомогою якого інші бізнеси (шпиталі, міста для здачі аналізів ітд.) можуть відправляти документи до системи до потрібний їм користувачам. Через це користувачі будуть бачити що цей сервіс має інтеграцію з якимсь бізнесом чи установою, і будуть більш охоче користуватися їхніми пропозиціями.
     2. Учасникам: Дає зручний сервіс для керування їхніми документами:
     3. Зберігання, завантаження, скачування та керування даним їх документів;
     Кожна з цих категорій також хочу щоб все було конфіденційно, без втрат даних, а також гарантовану стійкість до стресу системи.

   
     1.1.4 Бізнес ризики
     
     
     Проект має такі ризики:
     1. Конкуренція:  Існує можливість того, що інші компанії вже працюють над схожими продуктами або можуть ввести конкурентні рішення на ринок раніше. 
     2. Сприйняття продукту: Хоча існує попит на сервіси керування документами, користувачі можуть не прийняти нову ідею яка направлення на медичну сферу документообігу. 
     3. Швидкий розвиток технологій: Ринок та технології швидко розвиваються. Затримки в розробці можуть призвести до втрати конкурентних переваг та можливостей на ринку.
     4. Фінансові ризики:  можливість нехватки фінансів для розробки, виробництва, маркетингу та підтримки програмної системи. 
     5. Технічні проблеми: Є можливість виникнення помилок у пристроїв через надсильне та не обережне використання, через це користувачі можуть бути не задоволені через швидку поломку пристроїв
     Можливі рішеннями можуть бути:
     1. Конкуренція: Постійно відстежування ринку, розроблення унікальних функції, виходити на ринок швидко та розглядати партнерства.
     2. Сприйняття продукту: Проводити маркетингові дослідження, запускати пілотні проекти, організовувати інформативні кампанії та залучання медичних експертів.
     3. Швидкий розвиток технологій: Впроваджування постійних оновлень, використовування гнучкої архітектуру та створювати інноваційні команди.
     4. Фінансові ризики: Розробити фінансовий план, залучити інвесторів, оптимізувати витрати та розглянути можливість отримання грантів.
     5. Технічні проблеми: Провести якісне тестування, встановити систему підтримки, забезпечити користувачів інструкціями та надати гарантію на продукт.
     
     
     1.2 Концепція рішення
     1.2.1 Окреслення концепції
     
     
     Проект передбачає створення програмної системи, що перетворить спосіб передачі медичних документів та взаємодії з ними. Ця система зробить процес більш ефективним та зручним для користувачів.
     У майбутньому обмін медичними документами буде не просто процедурою, а спільним досвідом, де кожен учасник може взаємодіяти з розумний пристрій як зручний спосіб зберігання документів, та само ідентифікація. Вони зможуть працювати як носій інформації, а також ідентифікатор користувача, для того щоб йому не було потрібно носити з собою документ підтверджуючий його особистість.
     З інших частин, система надасть зручний спосіб додавання нових документів від тих фірм які ще не почали співпрацю з нашою системою, перегляд, і сортування. Зі сторони фірм ми додамо зручний інтерфейс використання нашого сервісу, щоб користувачі могли зручно і приємно ними користуватися. Передбачається що фірми будуть самі додавати документи коли вони їх створюють і хочуть видавати користувача. Та також користувач може додавати сам документи від фірм які не використовують систему, чи які не були додані по якійсь іншій причині. Додавати буде файли типу фотографій та PDF.
     Успіх нашого проекту визначатиметься рівнем задоволеності користувачів від взаємодії з медичними документами через нашу систему, збільшенням кількості організацій, які використовують нашу систему для передачі документів, а також підвищенням ефективності та прибутковості для медичних установ завдяки поліпшеному досвіду користувачів.
     Данні будуть зашифровані за допомогою шифрувальних алгоритмів, та будуть зберігатися в базі даних. Доступ до неї будуть мати тільки авторизовані користувачі(JWT tokens)
     
     
     1.2.2 Головна функціональність
     
     
     ГФ-1: Реєстрація та авторизація користувачів
     ГФ-2: Реєстрування пристрою для ідентифікації користувача
     ГФ-3: Записування даних на пристрій
     ГФ-4: Зчитування інформації з пристрою
     ГФ-5: Взаємодія телефона з пристроями через Bluetooth
     ГФ-6: Додавання документів через мобільний додаток
     ГФ-7:  Перегляд своїх даних та статистика через свій аккаунт
     ГФ-8: Багатомовний інтерфейс: Користувачі можуть користуватися додатком англійською й українською мовами.
     ГФ-9: Шифрування користувацьких та документів за допомогою “Advanced Encryption Standard”
     ГФ-10: Зберігання дат за допомогою PostgreSQL та типу дат з додавання часових зон, і показом дат і часу в інтернаціоналізованому стандарті на сайті з використанням функції мови JavaScript
     ГФ-11: Адміністративна панель
     ГФ-12: Імпортування та Експортування даних з бази даних
     

     1.2.3 Припущення та залежності
     

     З-1: Для коректного використання сервісу всі пристрої мають бути підключеними до інтернету.
     З-2: Користувачі мають правильно використовувати пристрої.
     З-3: Пристрої мають бути впроваджені батарейками для правильного ними функціонування.
     П-1: Кожний пристрій потрібно буде реєструвати.
     П-2: Клієнти готові платити за підписку за сервіс.
     П-3: Клієнт може придбати підписку на сервіс і купити пристрої для повноцінного користування.
     
     
     1.3 Рамки та обмеження проекту
     1.3.1 Рамки первинного випуску


     Серверна частина повинна включати:
     - Реєстрація користувачів: Створюйте нові акаунти з верифікацією;
     - Аутентифікація користувача: Вхід в систему за допомогою токенів (JWT);
     - Ведення ролей і прав доступу: Ролі (користувач, адміністратор) з відповідними правами;
     - Додавання документів: API для завантаження, зберігання та зв'язування документів з акаунтами;
     - Редагування даних облікового запису: Зміна персональних даних користувачів;
     - Видалення даних: Видалення облікових записів та їхніх документів;
     - Панель адміністратора: Інтерфейс для адміністраторів для редагування даних і налаштувань системи;
     - Розрахунок статистики: Відображає основну статистику користувача;
     - Шифрування даних: Використовування AES для шифрування конференційних даних;
     - Використовування хешування сіллю для зберігання паролів: Сольове хешування паролів за допомогою бібліотеки crypto-js[1];
     - Панель адміністрування бази даних: Редагування даних, виконання запитів, керування користувачами;
     - Імпорт та експорт даних: Імпорт та експорт даних для резервного копіювання або міграції;
     - Сортування даних: Сортування даних за різними критеріями (дата, тип документа, активність);
     - Захист від SQL-ін'єкцій: Використання підготовлених запитів та ORM;
     - Резервне копіювання даних: Регулярне автоматичне резервне копіювання бази даних.
     IoT частина повинна включати:
     - Реєстрація пристрою: Додавання нового пристрою до системи з унікальним ідентифікатором;
     - Налаштування при першому запуску: Ініціалізація та конфігурація пристрою при першому підключенні;
     - Виявлення пристрою при втраті зв’язку: Якщо пристрій був відключений від інтернету, але не вимкнений, він починає вібрувати та шуміти через певний час для полегшення його пошуку;
     Веб-частина повинна включати:
     - Реєстрація та вхід користувачів: Сторінки для створення облікового запису та входу до вже існуючого облікового запису;
     - Панель керування організацією: Інтерфейс для адміністраторів для управління організацією;
     - Адміністративна панель: Управління користувачами системи та даними системи;
     - Локалізований та інтернаціоналізований інтерфейс: Підтримка української та англійської мов, коректне відображення дати та часу, підтримка міжнародних символів;
     - Панель керування документами: Інтерфейс для додавання, редагування, перегляду та видалення документів;
     - Перегляд статистики: Інтерфейс для перегляду статистичних даних користувача.
     Мобільна частина повинна включати:
     - Реєстрація та вхід користувачів: Сторінки для створення облікового запису та входу до існуючого облікового запису;
     - Локалізований та інтернаціоналізований інтерфейс: Підтримка української та англійської мов, коректне відображення дати та часу, підтримка міжнародних символів;
     - Перегляд та редагування даних: Можливість надавання користувачу перегляду його документів, та зміни даних до цих самих документів.
     
     
     1.3.2 Рамки наступних випусків
     
     
     Серверна частина:
       - Аналітика даних: Збір, обробка та аналіз даних користувачів і пристроїв для отримання припущень та покращення системи;
       - Збір зворотного зв'язку від компаній: Функціонал для отримання та зберігання відгуків від компаній-користувачів;
       - Покращення API: Подальше покращення зовнішнього інтерфейсу для використання іншими бізнесами;
       - Резервне копіювання: Автоматичне резервне копіювання даних для безпеки та відновлення;
       - Шифрування та безпека: Збільшити об’єм даних який буде передаватися за допомогою безпечних методів шифрування та передачі даних.
     IoT-частина:
       - Можливість роботи без постійного підключення до інтернету: Один з пристроїв виступає в ролі передавача даних для інших;
       - Повна автономна робота: Пристрої можуть працювати без підключення до інтернету, зберігаючи дані локально;
       - Передача даних GPS: Надсилає координати пристрою на сервери для відстеження місцезнаходження;
       - Виявлення пристрою: Вібрація та шум при втраті інтернет-з'єднання для полегшення пошуку;
       - Оновлення програмного забезпечення: Віддалене оновлення прошивки пристрою.
     Веб-частина частина:
       - Перегляд статистики та аналітики: Інтерфейс для відображення зібраної статистики та аналітики;
       - Відгуки користувачів: Можливість залишати та переглядати відгуки;
       - Відстеження місцезнаходження: Перегляд останнього місцезнаходження ваших пристроїв на інтерактивній карті;
       - Керування користувачами: Керування обліковими записами користувачів та їхніми правами доступу;
       - Локалізація: Збільшення підтримки ще декількох мов доступних для використання користувачам;
     Мобільна частина:
       - Відстеження місцезнаходження на карті: Переглядання останнього місцезнаходження пристроїв на інтерактивній карті;
       - Пошук пристроїв без підключення до Інтернету: Знаходження пристроїв через Bluetooth навіть без підключення до Інтернету;
       - Швидка передача даних через Bluetooth: Швидке завантажування та передавання даних на пристрої через Bluetooth;
       - Локалізація: Збільшення підтримки ще декількох мов доступних для використання користувачам;
       - Завантаження документів: Зробити можливість завантажування документів до системи за допомогою мобільних пристроїв.

     
     1.3.3 Обмеження та винятки
     
     
     Проект матиме такі обмеження:
     - Водостійкість та ударостійкість: оскільки головною ідеєю проекту має бути пристрої які працюють як передатчики інформацію, вони мають бути стійкими до зовнішніх ушкоджень.
     - Підключення до мережі Інтернет: для забезпечення зв’язку з серверами та системою необхідне постійне підключення до мережі Інтернет. При його відсутності пристрої не зможуть працювати заплановано
     - Якість та новизна техніки: Для гарної праці сервісу на пристроях користувачів. Вони мають бути гарної якості, а також мають працювати на нових версіях операційних систем. Також користувачі мають мати оновлені та безперебійно працюючі програмні забезпечення, які потрібні для правильної роботи системи. Прикладом може бети браузер користувача. А також правильно працюючі компоненти пристроїв, такі як Bluetooth.
     
	 
     1.4 Бізнес-контекст
     1.4.1 Профілі зацікавлених сторін 
     
     
     Профілі зацікавлених сторін проекту наведені в таблиці 1.1.
     
     Таблиця 1.1 – Профілі зацікавлених сторін проекту
Зацікавлена сторона
Головна цінність
Ставлення
Головний інтерес
Обмеження
Бізнес
Можливі легкого та швидкого рішення для передачі медичних документів
Зацікавленість, очікування продукту що дешево задоволені потреби
Зручна передача та керування своїми документами
Доступ до мережі інтернету
Звичайні користувачі 

Зручність та легкість використання системою для передачі медичних документів
Зацікавленість, але чекають зручний та широкий функціонал
Зручна передача та керування своїми документами
Доступ до мережі інтернету
Розробник проекту 

Отримання прибутку, опиту, та слави з можливістю подальшого розширення компанії
Зацікавленість в успіху проекта та задоволенні цільової аудиторії 
Набуття навичок,
Добуття слави, Заробіток
Малий досвід розробки, Недостаток грошей, доступ до мережі Інтернет 
Інвестори 

Отримання прибутку 

Зацікавленість в успіху проекта та прибутку від нього 
Заробіток
Грошові обмеження


     1.4.2 Пріоритети проекту
     
     
     Пріоритети проекту наведені в таблиці 1.2.

     Таблиця 1.2 – Пріоритети проекту
Показник 
Виконання (етапи)
Обмеження (граничні значення)
Ступінь свободи (допустимий діапазон)
План робіт
продукт має бути випущеним до 01.07.2024

можливе відхилення від графіку на 1-2 місяці
Функціональність


90% функціоналу має працювати на релізі 1.0
Якість 


у випуску 1.0 повинні пройти 100% тестувань
Персонал 

Максимальний розмір команди це 1 розробник та адміністратор

Ціна

8000грн
Допустиме відхилення на 15%

     
     1.4.3 Робоче середовище
     
     
     Даний продукт буде використовуватися через браузер на ПК або за допомогою телефону та планшету. Для використання мобільного додатку має використовуватися система Android 5 або вище. Була вибрана ця версія через повну досяжність написаної програми для всіх телефонів. 80% телефонів досі знаходяться ці цій версій. І нові телефони також підтримують старі версій програм написаних на старі версії андроїду.
     Хостингом серверної частини буде Vercel. Це прекрасний вибір для легкого та швидкого розгортування серверу. Для клієнтської буде також використовуватися Vercel. Цей сервіс було вибрано за легку можливість розгорнути як і серверну так і веб частину. А головною причиною є дуже щедрий безплатний план використання.
     Додаток буде доступний в українській та англійській мовах завдяки локалізації та інтернаціоналізації. Яка буде отримана за допомогою бібліотеки i18n для JS.
     Базою даних буде PostgreSQL, розгорнута ця БД буде не Neon Db. Він має прекрасний пакет тестовий пакет для використання а також зберігання часових даних з врахуванням часових поясів.
     Для розробки серверної частини будуть використані технології Nest.js з використанням мови програмування Typescript. Цей фреймворк є дуже зручним для використання, і я маю опит праці з ним. Тому вибір був очевидний. Середовищем розробки для цього проекту буде Visual Studio Code. Сервіси: Eslint, prettier, NEST CLI. Головними бібліотеками:  class-validator, class-transformer, Prisma, i18n.
     У веб-застосунку буде використано React для розробки, і середовищем розробки для цього також може бути Visual Studio Code. React було вибрано через мій великий опит праці з цією бібліотекою компонентів, та через легке використання. Сервіси: Eslint, prettier, Next CLI. Головними бібліотеками:  Tailwind (для розробки стилів сайту), yup (валідація), react-hook-forms (створення зручних форм)
     Для розробки IoT частини проекту буде використовуватися ESP32, і середовищем розробки VS Code з використанням мови програмування MicroPython. На пристрої Arduino будуть встановлені Wi-Fi модулі та інш.
     Мобільний додаток буде розроблено на Kotlin. Середовищем розробки може бути Android Studio.


2 ПОСТАНОВКА ЗАДАЧІ
     
     
     Результатом аналізу попередньої частини (предметної області). Задачею цієї курсової це розробити інтегровану програмну систему, яка забезпечить зручне зберігання, передачу та взаємодію з медичними документами, що підвищить ефективність обміну медичною інформацією між користувачами та медичними установами.
     Після реалізації проекту, клієнт має можливість робити такі дії:
     - реєстрації та авторизація до програмної частини;
     - завантаження своїх документів до системи;
     - керування доступними йому документами які наявні у системі;
     - реєстрування своїх організації;
     - керування доступними його організації документів які наявні у системі;
     - завантаження документів до відповідних користувачів, від лиця організації.
     Для адміністратора має бути реалізований такий функціонал:
     - реєстрація та вхід у систему від лиця адміністратора;
     - управління даними користувачів системи;
     - перегляд, додавання, редагування, видалення документів;
     - перегляд, додавання, редагування, видалення організації;
     - експорт та імпорт даних системи;
     - експорт та імпорт сертифікатів системи.
     Окрім того, система має мати повноцінну підтримку локалізації. Це означає що інтерфейс системи та данні збереженні у ній, при відтворенні, мають бути доступними для розуміння для всіх культур на націй. Через це, інтерфейс зобов’язаний відтворювати на екрані різні кодові символьні таблиці. Також дати та час мають бути показані у відповідному форматі. Та ввід даних відбуватися у зручному для користувача форматі.


3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
     3.1 Побудова ER-діаграми
     
     
     На підставі аналізу предметної області, було розроблено основні сутності та встановлено зв’язки між ними які потрібно реалізувати в системі. Ці сутності представлено у вигляді ER-діаграми (див. рис. 3.1).
     

Рисунок 3.1 – ER-діаграма бази даних

     Сутність Організації – це сутність, яка зберігає інформацію про зареєстровані організації у системі, і вона є пов’язана з сутностями Користувачі та Файли типом зв’язку «один чи ноль до багатьох» в обох випадках.
     Сутність Користувачі – це сутність, яка зберігає інформацію про користувачів програмної системи, і вона є пов’язана з сутностями Файли, Токени та Ролі типом зв’язку «один чи нуль до багатьох» в обох випадках. Та сутністю Організації типом зв’язку «один до багатьох».
     Сутність Файли – це сутність, яка зберігає інформацію про файли, і вона є пов’язана з сутностями Організації типом зв’язку «один чи нуль до багатьох» та Користувачі типом «один до багатьох».
     Сутність Токени – ця сутність зберігає дані потрібні для автентифікації користувачів до системи, і вона є пов’язана з сутністю  Користувачі типом зв’язку «один до багатьох».
     Сутність Ролі – ця сутність зберігає дані потрібні для авторизації користувачів до системи, і вона є пов’язана з сутністю  Користувачі типом зв’язку «один до багатьох».
     
     
     3.2 Побудова логічної моделі бази даних на основі ER-діаграми

     
     Для того щоб база даних рахувалася нормальною, варто усунути можливі зв’язки «багато-до-багатьох» між сутностями. Проаналізувавши вже спроектовану модель, можна побачити, що таких зв’язків немає. Тому перейдемо до побудови логічної моделі бази даних на основі ER-діаграми.
     Отже, у логічній моделі бази даних будуть представлені такі сутності:
     - організації (Організації);
     - користувачі (Користувачі);
     - ролі (Ролі);
     - файли (Файли);
     - токени (Токени).
     
     Створимо таблицю організацій (Організації). Вона буде містити у собі такі атрибути: 
     - організація_id (первинний ключ) ;
     - дата_створення;
     - назва;
     - адреса;
     - пароль;
     - дата_останнього_оновлення.
     Перевіримо таблицю Організації на відповідність нормалізації:
     - усі атрибути атомарні: містять лише одне значення, а не множину;
     - відсутність повторюваності даних;
     - усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю користувачів (Користувачі). Вона буде містити у собі такі атрибути: 
     - користувач_id (первинний ключ),
     - пошта,
     - пароль,
     - провайдер,
     - дата_створення,
     - дата_останнього_оновлення,
     - ім'я,
     - організація_id (зовнішній ключ для зв’язку «багато-до-одного» з таблицею Організації).
     Перевіримо таблицю Користувачі на відповідність нормалізації:
     - усі атрибути атомарні: містять лише одне значення, а не множину;
     - відсутність повторюваності даних;
     - усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю ролей (Ролі). Вона буде містити у собі такі атрибути: 
     - роль_id (первинний ключ),
     - назва.
     Перевіримо таблицю Ролі на відповідність нормалізації:
     - усі атрибути атомарні: містять лише одне значення, а не множину;
     - відсутність повторюваності даних;
     - усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю файлів (Файли). Вона буде містити у собі такі атрибути: 
     - файл_id (первинний ключ),
     - тип,
     - дані,
     - дата_створення,
     - дата_оновлення,
     - розмір,
     - тип_документа,
     - організація_id (зовнішній ключ для зв’язку «багато-до-одного» з таблицею Організації),
     - користувач_id (зовнішній ключ для зв’язку «багато-до-одного» з таблицею Користувачі).
     Перевіримо таблицю Файли на відповідність нормалізації:
     - усі атрибути атомарні: містять лише одне значення, а не множину;
     - відсутність повторюваності даних;
     - усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю токенів (Токени). Вона буде містити у собі такі атрибути: 
     - токен_id (первинний ключ),
     - дата_створення,
     - якісний_до,
     - агент_користувача,
     - користувач_id (зовнішній ключ для зв’язку «багато-до-одного» з таблицею Користувачі).
     Перевіримо таблицю Токени на відповідність нормалізації:
     - усі атрибути атомарні: містять лише одне значення, а не множину;
     - відсутність повторюваності даних;
     - усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     За результатами проектування таблиць та зв’язків майбутньої бази даних, отримано її логічну схему (див. рис. 3.2).
     

Рисунок 3.2 – Логічна схема бази даних


4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
     4.1 Архітектура серверної частини
     
     
     У системи є три види користувачів: Адміністратори, Користувачі та Користувачі пристроїв, та самі Організації. Користувачі пристроїв, Користувачі можуть взаємодіяти з веб-частиною та мобільним застосунком. Поки адміністратори взаємодіють з веб-частиною задля адміністрування системи (редагування, створення та видалення даних про користувачів та пристроїв). В той самий час користувачі пристроїв взаємодіють з самими пристроями. Також є зовнішні системи які можуть використовувати наше АПІ задля використання системи від лиця якоїсь організації. 
     Для докладного ознайомленням з можливостями системи була створена UML діаграма прецедентів (див. додаток Б. рис. Б.1).
     Сервер написаний на фреймворку Nest.js, Дуже гнучкий фреймворк для JavaScript, він дозволяє писати код у виді дуже зручних модулів, та має базову підтримку Jest. І оперує в середовищі Node яке потрібне для праці написаного коду.
     У  якості бази даних використано PostgreSQL, до якої з серверного застосунка здійснюється доступ за допомогою технології Prisma[2], Це дуже зручна бібліотека яка дозволяє створювати та оперувати базою даних за допомогою моделей та класів і вона має свою мову написання схеми під назвою Prisma Schema.
     Для більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.1).

Рисунок 4.1 – Діаграма розгортання серверної частини програмної системи

     Для демонстрації та тестування API використовується OpenApi (Swagger), зручний інструмент для перегляду та тестування API, покращуючи якість та зручність розробки. Для забезпечення безпеки даних та конфіденційності використовується захищений протокол HTTPS, що захищає дані під час їхньої передач.
     Щодо шифрування паролів та створення токенів авторизації, в Nest.js я використовую бібліотеку для шифрування crypto-js. Для передачі та отримування використовується властивості REST API голови запиту та печива запиту. При отриманні запиту сервер перевіряє валідність за допомогою Guard які виконують код перед обробки запитом.
     Розроблений серверний застосунок побудований за принципами Modular Architecture[3], де модуль та складається з декількох шарів. Controller, який приймає запити, Service, який оброблює запити, Repository, який відправляє інформацію до Бази даних. І кожен рівень залежав від вищого.
     У якості способу організації коду було обрано CQRS (Command Query Responsibility Segregation), який розділяє команди, які змінюють стан системи, від запитів, які повертають дані про стан системи. Цей спосіб організації коду сприяє чіткому структуруванню коду та забезпечує легку розширюваність функціональності системи[4].
     В архітектура також був доданий захисник (Guard) який перевіряє запити на валідність запитаної інформації. Тобто на те що токен вже не зіпсувався, на валідність токену, та інше. 
     Ще використовуються інтерцептори (Pipeline Interceptors) які перехвачують запити та можуть їх блокувати, вони не будуть пропускати непідходящі данні до контролера. При відправленні відповіді використовується інтерцептор, який видаляє не підходящі данні, такі як паролі інше.
     Побачити архітектура серверного застосунка можливо ничже на рисунку у кінці підрозділу (див. додат. див. рис. 4.2).
     Приклади частин коду серверного застосунка представлено у додатку В.
Таким чином, було визначено технології й архітектуру серверної частини програмної системи.

Рисунок 4.2 – Діаграма пакетів серверної частини програмної системи
     4.2 Архітектура Веб частини
     
     
     Користувачами клієнтської частини розробленої системи є 2 типи акторів: адміністратор системи, який має доступ до всієї системи та звичайний клієнт якому доступна лише частина системи.
     Основними потребами клієнта є: можливість переглядати наявні документи, додавати документи, яких ще не існує, а також редагувати та видаляти їх. Під час перегляду користувач також повинен мати можливість легко завантажувати ці документи на свій пристрій. Користувач також може бути частиною організації і повинен мати можливість редагувати дані своєї організації, а також взаємодіяти з даними, що належать організації  (редагувати, видаляти, завантажувати).
     Основними потребами адміністратора є: можливість переглядати стан всієї системи, тобто організації, користувачів, документів. А також мати можливість редагувати ці дані (адміністрування), змінювати дані користувачів, змінювати дані організації та документи. А також видаляти дані з цих таблиць. Крім того, вони повинні мати можливість створювати резервні копії даних системи.
     Взаємодію звичайного користувача та адміністратора системи з клієнтською частиною програмної системи показана на наступній діаграмі (див. рис 4.3).

Рисунок 4.3 – Діаграма прецедентів клієнтської частини програмної системи

     Для написання клієнтської частини системи було обрано мову програмування TypeScript з використанням технології React, що забезпечує високу швидкодію розробки і зручність у використанні.
     Для реалізації елементів інтерфейсу було використано бібліотеки Styled Components та Tailwind, які надають зручну можливість написання стилей для компонентів. Styled Components бібліотека яка дає можливість одразу компоненти зі стилями, і після чого повторного виристання. Поки Tailwind надає можливість швидкого написання стилів одразу на компоненті.
     Для додання можливості локалізації інтерфейсу було використано бібліотеку i18next, що дозволяє легко і ефективно впроваджувати багатомовний інтерфейс та забезпечує зручний механізм перекладу текстових рядків. Для інтернаціоналізації часу використовується вбудований в JavaScript тип дат, який має можливість показувати формат дат відповідно до регіону користувача.
     Для реалізації сторінок та моментальний перехід між ними по веб сторінці використано пакет react-router-dom, яка надає можливість для створення реактивної навігації та управління маршрутами на веб сторінці та історією цих маршрутів.
     Для розгортання серверу використано інструмент компіляції Vite[5] він дозволяє легко налаштовувати середовище розробки та підтримує автоматичне оновлення в реальному часі. 
     Для візуалізації використаних пакетів було розроблено діаграму пакетів (див. рис. 4.4).
     
Рисунок 4.4 – Діаграма пакетів клієнтської частини програмної системи
     Проект використовує «Module Architecture». Головна ідея цієї архітектури, в можливості повторне використання написаних модулей, а майбутніх проектах, з мінімальною потребою у повторному використання коду. Але все одно вона має задатки також на шарову архітектуру, через чітке розділення на шари в середині модулей. 
     Кожна з цих директорій зберігає невеличкі частини коду які використовуються в модулях. В рages зберігаються сторінки між якими буде переходити користувач. Саме ці сторінки використовують в собі контейнери з modules, які вже і визначають якусь логіку. Ці контейнери розбиті по модулям за призначенням. Саме ці модулі вже використовують код з components, types, utils, hooks та інших директорій.
     Усі конфіденційні дані передаються за допомогою шифрування ключем, без якого неможливо дізнатися що за інформація там лежить.
     Для більш детальної візуалізації архітектури системи було розроблено діаграму компонентів (див. рис. 4.5).
     
Рисунок 4.5 – Діаграма компонентів клієнтської частини програмної системи
     Взаємодія користувача з клієнтською частиною починається з введення даних профілю (при реєстрації або входу). Після авторизації, згідно ролі користувача, взаємодія розділяється на клієнтську та адміністраторську.
     Клієнт має можливість переглядати доступні йому документи, редагувати та видаляти їх. При перегляданні він має можливість завантажування на власний пристрій. Також якщо він є частиною організації, він може редагувати та видаляти дані тієї організації.
     Адміністратор має можливість повного контролю всієї системи. Він може редагувати, додавати, та видаляти дані з системи таблиць Користувачів, Документів та Організації. Йому також надана можливість експортування та імпортуванні даних системи за допомогою зовнішнього сервісу.
     Для більш детальної візуалізації взаємодії користувачів з клієнтської частиною системи було розроблено діаграму взаємодії (див. рис. 4.6).
     Таким чином, за допомогою діаграм пакетів, компонентів та взаємодії було визначено основні технології та архітектуру веб додатку системи.
     Приклади коду клієнтської частини системи представлено у додатку Г.
     
Рисунок 4.6 – Діаграма взаємодії клієнтської частини програмної системи
     4.3 Архітектура мобільного додатку


     Мобільна частина написана на мові програмування Kotlin[6], який дозволяє швидко та гнучко писати програми до ОС Андроїд. Проект використовує «Module Architecture». Головна ідея цієї архітектури, в можливості повторного використання написаних модулей при майбутніх потребах, з мінімальною потребою у повторному написанні коду. Але все одно вона має задатки також на шарову архітектуру, через чітке розділення на шари всередині модулей. 
	 Кожен модуль розбитий на піддиректорії. Основні це Activities та Services. Також можуть бути допоміжні як Models та Helpers. Активності виступають які показний шар, вже який звертається до сервісів, які вже самі дають запити до сервера. 
     Шар Activities мобільного застосунку використовує Kotlin для написання коду, який в подальшому компілюється в код для платформи Android. Цей шар складається з Layout, що написані з допомогою мови розмітки XAML, Activity, що додає можливість зчитування та взаємодії з написаним шаблоном.
     Шар Services забезпечує реалізації методів для з’єднання з API, конкретні методи для створення моделей, авторизації, тощо. Цей шар використовує сутності з конфігураціями, ці сервіси вже знаходятся в модулях, в яких вони і налаштовуються.
     Локалізація реалізована з допомогою файлів ресурсів та Locale та Configuration. Файли ресурсів додаються як частина маніфесту програми, а Locale та Configuration вибирає файл, який потрібно зчитати при наданні потрібних тобі налаштувань. 
     Була створена діаграма компонентів (див. рис. 4.7), що показує як пов’язані сторінки сутностей з сервісами, та які елементи керування вони дають.

Рисунок 4.7 – Діаграма компонентів мобільної програмної частини

     Для розуміння ситуацій використання програмної системи була сформована діаграма прецедентів (див. рис. 4.8).
Рисунок 4.8 – Діаграма прецедентів мобільної програмної частини

     Користувач може ввійти в аккаунт, вийти з нього. Оновлювати дані свого профіля, та переглядати його. З переглядом стану своїх документів, завантаженням на свій пристрій, а також видаленням їх.
     Була створена діаграма пакетів mobile частини проєкту (див. рис. 4.9).
     

Рисунок 4.9 – Діаграма пакетів мобільної програмної частини

     Ця частина проекту складається з таких пакетів як Main (основна функціональність) та i18n (який дозволяє додавати локалізацію за допомогою такої системи як Recourse Manager який дозволяє додавати переклади тексту за допомогою файлів ресурсів), Services (в якому зберігаються сервіси проекту, які і роблять більшу частину бізнес логіки мобільного додатку) та Activities (в якому зберігаються активності які дають можливість додати реактивність до написаних кусочків за допомогою мови розмітки XAML), і інші… Вся їх функціональність була описана в попередніх розділах, а залежності показані на рисунку 4.9.
     Була створена діаграма станів (див. рис. 4.10), для відображення станів, в яких може бути застосунок. 


Рисунок 4.10 – Діаграма пакетів мобільної програмної частини

     Приклади частин коду серверного застосунка представлено у додатку Д.
     Таким чином, було визначено технології й архітектуру мобільной частини програмної системи.


5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
     5.1 Виклик і завантаження
     
      
     Для завантаження програми буде достатньо простого розархівування архіву в якому розповсюджується програма. Для роботи програми вам потрібне середовище «Node» для виконання мови програмування JavaScript. Виключно для серверної частини вам також буде потрібен «WSL» та «Docker». При відкритті директорії програми, вам потрібно буде створити файл «./.env» у головній директорії проекту. Наповнення цього файлу можливо побачити на рисунку 5.1
     

Рисунок 5.1 – Наповнений файл .env

	Щоб знайти шаблон цього файлу, ви можете відкрити файл «./.env.example» В якому будуть знаходитися всі пусті стрічки без значень,  які вже можливо скопіювати, та вставити в головний файл. Для запуску програми, цей код має знаходитись у середовищі Linux, з вже запущеною програмною Docker. Для початку програми, вам потрібно ввести таку стрічку в терміналі: «npx docker:up». Після чого програма почне працювати, результат цієї стрічки можливо побачити на рисунку 5.2


Рисунок 5.2 – Результат виконання команди «npx docker:up»

	Після чого можливо почати користуватися серверною частиною. Сервер з самого початку буде доступний за портом 3000. При потребі це змінити. Треба відкрити файл «./docker-compose.dev.yml» та змінити підкреслене число (див. рис. 5.3) задля зміни порту на якому буде доступний сервер для виклику його коду.


Рисунок 5.3 – Число яке потрібно змінити задля зміни порту сервера

	Для початку веб застосунку вам спочатку також треба змінити данні в файлі «./.env» В ньому потрібно вставити стрічку підключення для сервера. Вигляд файлу «./.env.example» з якого можливо скопіювати вже заготовлені значення можливо побачити на рисунку 5.4


Рисунок 5.4 - Наповнений файл ./.env.example
     «VITE_AES_KEY» та «AES_KEY» які можливо побачити на рисунка 5.1 та 5.4 мають бути однаковими, тому що це ключ шифрування запитів до сервера, і через не рівняння цих значень, програмна система перестане працювати.
     Для початку роботи веб додатку потрібно писати команду «yarn dev» у термінал. Результат роботи цієї команди можливо побачити на рисунку 5.5. Також на ньому буде підкреслена стрічка з якої можливо буде дізнатися по якому посиланню можливо почати користуватися веб-частиною.


Рисунок 5.5 – Результат запуску веб-частини, і місце знаходження посилання

	Для роботи мобільної частини, буде достатньо запустити проект, і вже саме середовище налаштує головні частини проекту. Для запуску також буде потрібно встановити середовище розробки «Android Studio» та «Java Runtime» вже які і будуть запускати та налаштовувати мобільний додаток.


     5.2 Призначення і логічна структура
      
     
     Функції які були реалізовані в програмі, можливо розбити на декілька модулів, такі як:
     − авторизація та автентифікація;
     − документи;
     − організації;
     − зовнішній інтерфейс для організації;
     − дані системи;
     − адміністрування системи;
     − користувачі системи;
     − інтернаціоналізація.
     Модуль «Авторизація та аутентифікація» містить функції для входу в систему під конкретною роллю та створення нового аккаунту. Реєстрація дозволяє клієнту створити аккаунт у базі даних і в подальшому дає можливість отримувати доступ до нього за допомогою пошти та пароля. 
     Модуль «Документи» містить функції для перегляду, додавання, редагування та видалення документів. Цей модуль забезпечує управління всіма типами документів, що зберігаються в системі, та їх доступність для користувачів.
     Модуль «Організації» містить функції перегляду, додавання, редагування та видалення організацій. Цей модуль дозволяє керувати інформацією про різні організації, які взаємодіють з системою, а також налаштовувати їхні профілі та доступ.
     Модуль «Зовнішній інтерфейс для організації» містить функції для забезпечення взаємодії організацій з системою через API. Це включає в себе надання можливості організаціям обмінюватися даними (документами) та інтегрувати свої системи з нашою.
     Модуль «Системні дані» є адміністративним і містить функції для експорту та імпорту системних даних. Цей модуль дозволяє адміністраторам створювати резервні копії та відновлювати дані.
     Модуль «Адміністрування системи» є адміністративним і містить функції для налаштування та управління параметрами системи. Сюди входить управління конфігурацією, налаштуваннями безпеки та контроль доступу до різних функцій системи.
     Модуль «Користувачі системи» є адміністративним і містить функції для управління користувачами системи. Сюди входить створення, редагування, видалення користувачів, а також налаштування їх прав доступу та ролей.
     Модуль «Інтернаціоналізація» містить функції для підтримки декількох мов у системі. Він дозволяє користувачам обирати мову інтерфейсу, а також забезпечує переклад усіх текстових елементів системи для різних мовних груп.


     5.3 Опис програмної реалізації
     
     
     При відкритті клієнтського застосунка можна побачити головну сторінку З неї можна перейти до сторінки реєстрації (див. рис. 5.6). 
     

Рисунок 5.6 – Сторінка реєстрації

	З неї можливо перейти на сторінку входу системи, її можливо побачити на рисунку 5.7

Рисунок 5.7 – Сторінка входу

	Після входу в систему, ми можемо перейти на сторінку профілю (див. рис. 5.8)


Рисунок 5.8 – Сторінка профілю

	На цій сторінці ми можемо побачити форму оновлення даних, результат оновлення даних профіля (ім’я профілю) можливо побачити на рисунку 5.9. А також меню профіля яке дозволяє оглядати свою статистику, та керувати даними своєї організації.


Рисунок 5.9 – Повідомлення о оновленні профіля

	 Меню зміни локалізації системи. Система дозволяє вибирати між Українською та Англійською мовами.


Рисунок 5.10 – Меню на якому можливо змінити локалізацію

	Сторінка профілю після зміни локалізації на Українську можливо побачити на рисунку 5.11.


Рисунок 5.11 – Сторінка профілю з зміненою мовою інтерфейсу

	За допомогою навігаційного меню, можливо перейти на сторінку твоїх документів (див. рис. 5.12).


Рисунок 5.12 – Сторінка документів
	
     На цій сторінці можливо оглянути доступні документи, після чого можливо: додати, оновити, скачати та видалити з системи ці документи. Сторінку додавання документа можливо побачити на рисунку 5.13.


Рисунок 5.13 – Сторінка додавання документів

	Після чого повинен з’явитися новий документ (див. рис. 5.14)

Рисунок 5.14 – Сторінка документів з доданим новим документом

     Також ці документи можливо оновлювати (див. рис. 5.15).

Рисунок 5.15 – Сторінка оновлення документів

	Після чого вибраний документ має оновитися (див. рис. 5.16)


Рисунок 5.16 – Сторінка документів з оновленим документом

     Окрім цього, кожен з документів можливо завантажити локально на пристрій користувача за допомогою натискання на синю кнопку з іконкою завантаження. Після чого має з’явитися вікно вибору директорії для збереження. Потім документ має скачатися на пристрій користувача (див. рис. 5.17). Де вже він зможете переглядати їх на своєму пристрої (див. рис. 5.18).

Рисунок 5.17 – Повідомлення від браузера о завантаженому документі


Рисунок 5.18 – Локально завантажений документ

     Окрім цього, на сторінці профілю можливо переглянути статистику користувача відносно його файлів у системі (див. рис. 5.19).

Рисунок 5.19 – Сторінка зі статистикою користувача

	Також, користувач може реєструвати нову організацію чи додавати себе як користувача вже існуючої. В обох випадках використовується пароль доступу до організації.


Рисунок 5.19 – Сторінка реєстрування та додавання себе до організації

	Після чого, користувач зможе побачити документи із його організації (див. рис. 5.20).

Рисунок 5.20 – Сторінка документів організації

     Також якщо обліковий запис у який було введений, є адміністратором. То йому будь доступні сторінки для редагування всіх даних системи. Першою доступною сторінкою буде сторінка керування користувачами (див. рис. 5.21)
 

Рисунок 5.21 – Сторінка керування користувачами системи

     На ній можливо як видаляти, так і змінювати дані системи.  Також ще є дві головні адміністративні сторінки для адміністрування даних організації (див. рис. 5.22) та документів (див. рис. 5.23)


Рисунок 5.22 – Адміністративна сторінка організацій


Рисунок 5.23 – Адміністративна сторінка документів

	Таким чином, було описано можливості взаємодії користувача з розробленою програмною системою. Мобільна частина майже повністю копіює можливості веб-частини, тому немає сенсу додавати рисунки з неї. Запис результатів функціонального тестування доступний за посиланням: https://youtu.be/U5xgb6LWBpA (дата звернення: 16.06.2024).


ВИСНОВКИ


     В результаті проведеної роботи було створено програмну систему для автоматизації процесу зберігання та управління медичними і звичайними документами. Під час розробки було проведено аналіз предметної області, спроектовано структуру бази даних, розроблено архітектуру серверної частини на основі Nest.js, клієнтську частину на основі React та мобільний додаток на основі Kotlin. Веб-застосунок використовує технології React, а серверна частина побудована з використанням Nest.js і бази даних PostgreSQL.
     Програмна система забезпечує зручну реєстрацію та авторизацію користувачів, управління документами, завантаження та зберігання файлів, а також інтеграцію із зовнішніми організаціями через API. Користувачі можуть легко керувати своїми документами, встановлювати доступи для зовнішніх організацій та отримувати доступ до своїх медичних записів.
     Система також підтримує адміністрування користувачів, управління даними та налаштуваннями системи, експорт та імпорт даних. Використання сучасних технологій та підходів до програмування, таких як TypeScript, забезпечує високу якість коду та зручність його підтримки.
     Завдяки використанню модульної архітектури, система є гнучкою та легко розширюваною, що дозволяє її адаптувати під різні потреби користувачів та інтегрувати з іншими сервісами. Розроблена система сприятиме підвищенню ефективності управління документами та поліпшенню взаємодії між користувачами та зовнішніми організаціями.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
     
      
     1. Crypto-js npm package. JavaScript library of crypto standards. URL: https://www.npmjs.com/package/crypto-js  (дата звернення: 25.05.2024).
     2. Prisma. Next-generation Node.js and TypeScript ORM. URL: https://www.prisma.io/orm (дата звернення: 25.05.2024).
     3. Nest.Js Modular Architecture. URL: https://docs.nestjs.com/modules (дата звернення: 25.05.2024).
     4. Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley Professional Computing Series) / R. Helm та ін. Addison-Wesley Professional, 1995. 395 р
     5. Vite – Best JavaScript Bundler. URL: https://vitejs.dev/guide/ (дата звернення: 25.05.2024). 
     6. Kotlin mobile programming language. URL: https://vitejs.dev/guide/  (дата звернення: 25.05.2024).

ДОДАТОК А
Результат перевірки на плагіат


Рисунок А.1 – Результат перевірки на плагіат


ДОДАТОК Б
Діаграма прецедентів


Рисунок Б.1 – Діаграма прецедентів 


ДОДАТОК В
Програмний код серверної частини
В.1 Код файлу для налаштування серверного додатка

1	import { ValidationPipe } from '@nestjs/common';
2	import { NestFactory } from '@nestjs/core';
3	import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
4	import * as cookieParser from 'cookie-parser';
5	import { config } from 'dotenv';
6	
7	import { AppModule } from './app.module';
8	
9	import 'dotenv/config';
10	config();
11	
12	async function bootstrap() {
13	  const app = await NestFactory.create(AppModule);
14	
15	  app.use(cookieParser());
16	  app.setGlobalPrefix('api');
17	  app.useGlobalPipes(new ValidationPipe());
18	
19	  if (process.env.NODE_ENV === 'development') {
20	    app.enableCors({
21	      origin: true,
22	      credentials: true,
23	    });
24	
25	    const config = new DocumentBuilder()
26	      .setTitle('DocMe API')
27	      .setBasePath('api')
28	      .build();
29	    const document = SwaggerModule.createDocument(app, config);
30	    SwaggerModule.setup('swagger', app, document);
31	  }
32	
33	  await app.listen(3000);
34	}
35	
36	bootstrap();	


В.2 Код файлу для дешифрування зашифрованих даних


1	import { createParamDecorator, ExecutionContext } from '@nestjs/common';
2	import { AES, enc } from 'crypto-js';
3	
4	export const DecipherBody = createParamDecorator(
5	  (data: unknown, ctx: ExecutionContext) => {
6	    const request = ctx.switchToHttp().getRequest();
7	    const ciphertext = request.body.data;
8	    const bytes = AES.decrypt(ciphertext, process.env.AES_KEY);
9	    const originalText = bytes.toString(enc.Utf8);
10	
11	    return JSON.parse(originalText);
12	  },
13	);


В.3 Код файлу для дешифрування зашифрованих даних


1	import { HttpService } from '@nestjs/axios';
2	import {
3	  BadRequestException,
4	  Body,
5	  Controller,
6	  Get,
7	  HttpStatus,
8	  Param,
9	  Post,
10	  Res,
11	  UnauthorizedException,
12	} from '@nestjs/common';
13	import { ConfigService } from '@nestjs/config';
14	import { Response } from 'express';
15	
16	import { Auth, Cookie, Public, Serialize, UserAgent } from '@/decorators';
17	
18	import { AuthService } from './auth.service';
19	import { SignInDto, SignUpDto } from './dto';
20	import { Tokens } from './interfaces';
21	import { UserResponse } from '../user/user.response';
22	
23	const REFRESH_TOKEN = 'refreshToken';
24	
25	@Public()
26	@Controller('auth')
27	export class AuthController {
28	  constructor(
29	    private readonly authService: AuthService,
30	    private readonly configService: ConfigService,
31	    private readonly httpService: HttpService,
32	  ) {}
33	
34	  @Serialize()
35	  @Post('signup')
36	  async signUp(@Body() dto: SignUpDto) {
37	    const user = await this.authService.register(dto);
38	
39	    if (!user) {
40	      throw new BadRequestException(
41	        `Something went wrong when trying to register user: ${JSON.stringify(
42	          dto,
43	        )}`,
44	      );
45	    }
46	
47	    return new UserResponse(user);
48	  }
49	
50	  @Post('signin')
51	  async signIn(
52	    @Body() dto: SignInDto,
53	    @Res() res: Response,
54	    @UserAgent() agent: string,
55	  ) {
56	    const tokens = await this.authService.login(dto, agent);
57	
58	    if (!tokens) {
59	      throw new BadRequestException(
60	        `Unable to login with: ${JSON.stringify(dto)}`,
61	      );
62	    }
63	
64	    this.setRefreshTokenToCookies(tokens, res);
65	  }
66	
67	  @Post('logout')
68	  async logout(
69	    @Cookie(REFRESH_TOKEN) refreshToken: string,
70	    @Res() res: Response,
71	  ) {
72	    if (!refreshToken) {
73	      res.sendStatus(HttpStatus.OK);
74	    }
75	
76	    await this.authService.deleteRefreshToken(refreshToken);
77	    res.cookie(REFRESH_TOKEN, '', {
78	      httpOnly: true,
79	      secure:
80	        this.configService.get('NODE_ENV', 'development') === 'production',
81	      expires: new Date(),
82	    });
83	    res.sendStatus(HttpStatus.OK);
84	  }
85	
86	  @Get('refresh-tokens')
87	  async refreshTokens(
88	    @Cookie(REFRESH_TOKEN) refreshToken: string,
89	    @Res() res: Response,
90	    @UserAgent() agent: string,
91	  ) {
92	    if (!refreshToken) {
93	      throw new UnauthorizedException();
94	    }
95	
96	    const tokens = await this.authService.refreshTokens(refreshToken, agent);
97	
98	    if (!tokens) {
99	      throw new UnauthorizedException();
100	    }
101	
102	    this.setRefreshTokenToCookies(tokens, res);
103	  }
104	
105	  @Auth('ADMIN')
106	  @Post('make-admin/:id')
107	  makeAdmin(@Param('id') id: string) {
108	    return this.authService.makeAdmin(id);
109	  }
110	
111	  private setRefreshTokenToCookies(tokens: Tokens, res: Response) {
112	    if (!tokens) {
113	      throw new UnauthorizedException();
114	    }
115	
116	    res.cookie(REFRESH_TOKEN, tokens.refreshToken.token, {
117	      httpOnly: true,
118	      sameSite: 'lax',
119	      expires: new Date(tokens.refreshToken.exp),
120	      secure:
121	        this.configService.get('NODE_ENV', 'development') === 'production',
122	      path: '/',
123	    });
124	
125	    res.status(HttpStatus.CREATED).json({ accessToken: tokens.accessToken });
126	  }
127	}


В.3 Код файлу для дешифрування зашифрованих даних

 
1	import { Injectable, OnModuleInit } from '@nestjs/common';
2	import { PrismaClient } from '@prisma/client';
3	
4	@Injectable()
5	export class PrismaService extends PrismaClient implements OnModuleInit {
6	  async onModuleInit() {
7	    let counter = 0;
8	
9	    while (true) {
10	      try {
11	        await this.$connect();
12	        console.log('DB connected');
13	        break;
14	      } catch {
15	        await new Promise((r) => setTimeout(r, 2000));
16	        counter++;
17	        console.log(`Retrying to connect to DB... ${counter}`);
18	
19	        if (counter > 10) {
20	          console.error('DB connection failed');
21	          break;
22	        }
23	      }
24	    }
25	  }
26	}


ДОДАТОК Г
Програмний код веб-частини
Г.1 Код файлу для налаштування клієнтської частини


1	import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
2	import React from 'react';
3	import ReactDOM from 'react-dom/client';
4	import { I18nextProvider } from 'react-i18next';
5	import { HashRouter } from 'react-router-dom';
6	import { ThemeProvider } from 'styled-components';
7	
8	import App from './App';
9	import { AuthProvider } from './modules/auth/contexts/AuthProvider';
10	import i18n from './modules/localization/containers';
11	
12	import theme from '@/constants/theme';
13	
14	const queryClient = new QueryClient();
15	
16	ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
17	  <HashRouter>
18	    <I18nextProvider i18n={i18n}>
19	      <QueryClientProvider client={queryClient}>
20	        <ThemeProvider theme={theme}>
21	          <AuthProvider>
22	            <App />
23	          </AuthProvider>
24	        </ThemeProvider>
25	      </QueryClientProvider>
26	    </I18nextProvider>
27	  </HashRouter>,
28	);


Г.2 Код файлу сторінки для входу в обліковий запис 



1	import { yupResolver } from '@hookform/resolvers/yup';
2	import { useForm } from 'react-hook-form';
3	import { toast } from 'react-toastify';
4	import { object, string, ObjectSchema } from 'yup';
5	
6	import { useAuth } from '../../hooks';
7	
8	import {
9	  Button,
10	  CardForm,
11	  ContainerDiv,
12	  ErrorMessage,
13	  FormInput,
14	  FormInputPassword,
15	  StateSuspense,
16	  Title,
17	} from '@/components';
18	import { PasswordRegex } from '@/constants';
19	import { useLoading } from '@/hooks';
20	import { SignInFormValues } from '@/types';
21	
22	const schema: ObjectSchema<SignInFormValues> = object({
23	  email: string().email('Input is invalid email').required('Email is required'),
24	  password: string()
25	    .trim()
26	    .min(8, 'Password must be at least 8 characters long')
27	    .max(32, 'Password must be at most 32 characters long')
28	    .matches(PasswordRegex, {
29	      message:
30	        'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character',
31	    })
32	    .required('Password is required'),
33	});
34	
35	const SignInContainer = ({ onSubmit }: { onSubmit: () => void }) => {
36	  const {
37	    register,
38	    handleSubmit,
39	    formState: { errors },
40	  } = useForm({
41	    resolver: yupResolver<SignInFormValues>(schema),
42	    mode: 'onChange',
43	  });
44	
45	  const { signIn } = useAuth();
46	
47	  const { loading, error, startLoading, stopLoading, errorOccurred } =
48	    useLoading();
49	
50	  const onFormSubmit = async (data: SignInFormValues) => {
51	    try {
52	      startLoading();
53	
54	      await toast.promise(signIn(data), {
55	        pending: 'Signing in...',
56	        success: 'Successfully signed in',
57	        error: 'Failed to sign in',
58	      });
59	
60	      stopLoading();
61	      onSubmit();
62	    } catch {
63	      errorOccurred(new Error('Credentials are invalid'));
64	    }
65	  };
66	
67	  return (
68	    <ContainerDiv>
69	      <CardForm onSubmit={handleSubmit(onFormSubmit)}>
70	        <Title>Sign Up</Title>
71	
72	        <ErrorMessage message={error?.message} />
73	
74	        <FormInput label={'email'} register={register} errors={errors} />
75	
76	        <FormInputPassword
77	          label={'password'}
78	          register={register}
79	          errors={errors}
80	        />
81	
82	        <StateSuspense show={!loading} fallback={<div>Loading</div>} />
83	
84	        <Button type="submit">Submit</Button>
85	      </CardForm>
86	    </ContainerDiv>
87	  );
88	};
89	
90	export default SignInContainer;


Г.3 Код файлу сторінки для оновлення даних облікового запису 


1	import { yupResolver } from '@hookform/resolvers/yup';
2	import { useQuery } from '@tanstack/react-query';
3	import { AES } from 'crypto-js';
4	import { useEffect } from 'react';
5	import { useForm } from 'react-hook-form';
6	import { useTranslation } from 'react-i18next';
7	import { toast } from 'react-toastify';
8	import { ObjectSchema, object, string, ref } from 'yup';
9	
10	import { Form, FormDiv } from './styles';
11	
12	import {
13	  Button,
14	  ErrorMessage,
15	  FormInput,
16	  FormInputPassword,
17	  MainContainerSection,
18	  Title,
19	} from '@/components';
20	import { ContainerLoader } from '@/components';
21	import { AES_KEY, PasswordRegex } from '@/constants';
22	import { User } from '@/models';
23	import { useAxios } from '@/modules/auth';
24	import { SignUpFormValues, UpdateProfileFormValues } from '@/types';
25	import { removeEmpty } from '@/utils';
26	
27	const schema: ObjectSchema<UpdateProfileFormValues> = object({
28	  email: string().email('Input is invalid email').notRequired(),
29	  nickname: string()
30	    .trim()
31	    .matches(/.{4,32}/, {
32	      excludeEmptyString: true,
33	      message: 'Must be between 4 and 32 characters long',
34	    }),
35	  password: string()
36	    .trim()
37	    .matches(/.{8,32}/, {
38	      excludeEmptyString: true,
39	      message: 'Must be between 8 and 32 characters long',
40	    })
41	    .matches(PasswordRegex, {
42	      excludeEmptyString: true,
43	      message:
44	        'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character',
45	    }),
46	  passwordConfirmation: string()
47	    .oneOf([ref('password'), null], 'Passwords must match')
48	    .notRequired(),
49	});
50	
51	const ProfileContainer = () => {
52	  const {
53	    register,
54	    handleSubmit,
55	    formState: { errors, touchedFields },
56	    watch,
57	    trigger,
58	    reset,
59	  } = useForm({
60	    resolver: yupResolver<UpdateProfileFormValues>(schema),
61	    mode: 'onChange',
62	  });
63	
64	  const axiosAuth = useAxios();
65	  const { t } = useTranslation();
66	
67	  const {
68	    data: profileData,
69	    error,
70	    isLoading,
71	    isRefetching,
72	    refetch,
73	  } = useQuery({
74	    queryKey: ['profile'],
75	    queryFn: () => axiosAuth.get<User>('/profile'),
76	  });
77	
78	  const password = watch('password');
79	
80	  useEffect(() => {
81	    if (touchedFields.password) {
82	      trigger('passwordConfirmation');
83	    }
84	  }, [password, trigger, touchedFields.password]);
85	
86	  const onFormSubmit = async (data: SignUpFormValues) => {
87	    try {
88	      await toast.promise(axiosAuth.patch<User>('profile', data), {
89	        pending: 'Updating profile...',
90	        success: 'Successfully updated profile',
91	        error: 'Failed to update profile',
92	      });
93	
94	      reset();
95	      refetch();
96	    } catch (error) {
97	      console.error(error.response.data.message);
98	    }
99	  };
100	
101	  if (isLoading || isRefetching) {
102	    return <ContainerLoader />;
103	  }
104	
105	  return (
106	    <MainContainerSection>
107	      <Title>{t('your-profile')}</Title>
108	      <Form onSubmit={handleSubmit(onFormSubmit)}>
109	        {/* <div>image</div> */}
110	        <FormDiv>
111	          <ErrorMessage message={error?.message} />
112	
113	          <FormInput
114	            placeholder={profileData?.data?.email}
115	            label={'email'}
116	            register={register}
117	            errors={errors}
118	          />
119	
120	          <FormInput
121	            placeholder={profileData?.data?.nickname}
122	            label={'nickname'}
123	            register={register}
124	            errors={errors}
125	          />
126	
127	          <FormInputPassword
128	            label={'password'}
129	            register={register}
130	            errors={errors}
131	          />
132	
133	          <FormInputPassword
134	            label={'passwordConfirmation'}
135	            register={register}
136	            errors={errors}
137	          />
138	
139	          <Button type="submit">{t('submit')}</Button>
140	        </FormDiv>
141	      </Form>
142	    </MainContainerSection>
143	  );
144	};
145	
146	export default ProfileContainer;


Г.4 Код файлу для зберігання даних о обліковому записі в який зайшли 


1	import { jwtDecode } from 'jwt-decode';
2	import { useContext, useEffect, useState } from 'react';
3	
4	import useRefreshToken from './useRefreshToken';
5	import { AccessTokenResponse } from '../types/responses';
6	
7	import { AuthContext, useAxios } from '@/modules/auth';
8	import { SignInFormValues, SignUpFormValues } from '@/types';
9	
10	const useAuth = () => {
11	  const [isReady, setIsReady] = useState(false);
12	
13	  const { setToken, clearToken, accessToken } = useContext(AuthContext);
14	
15	  const axios = useAxios();
16	  const refresh = useRefreshToken();
17	
18	  const signIn = async (data: SignInFormValues) => {
19	    const res = await axios.post<AccessTokenResponse>('/auth/signin', data);
20	    const accessToken = res.data.accessToken;
21	
22	    setToken(accessToken);
23	  };
24	
25	  const signUp = async (data: SignUpFormValues) => {
26	    //TODO add toast notification
27	    axios.post('/auth/signup', data);
28	  };
29	
30	  const logOut = () => {
31	    axios.post('/auth/logout');
32	    clearToken();
33	  };
34	
35	  const authorized = () => !!accessToken;
36	
37	  useEffect(() => {
38	    (async () => {
39	      const localStorageToken = localStorage.getItem('accessToken');
40	
41	      try {
42	        if (localStorageToken) {
43	          const payload = jwtDecode(localStorageToken);
44	
45	          if (payload.exp * 1000 < Date.now()) {
46	            throw new Error('Token expired');
47	          }
48	
49	          setToken(localStorageToken);
50	        }
51	      } catch (error) {
52	        const newToken = await refresh();
53	
54	        setToken(newToken);
55	      }
56	
57	      setIsReady(true);
58	    })();
59	  }, []);
60	
61	  return {
62	    isReady,
63	    signIn,
64	    signUp,
65	    logOut,
66	    authorized,
67	  };
68	};
69	
70	export default useAuth;


ДОДАТОК Д
Програмний код мобільної частини
Д.1 Код файлу активності для входу в обліковий запис


1	package com.example.lb5.authorization.activities
2	
3	import MyPreferences
4	import com.example.lb5.profile.activities.ProfileActivity
5	import SignInService
6	import android.content.Intent
7	import android.os.Bundle
8	import android.widget.Button
9	import android.widget.EditText
10	import android.widget.Toast
11	import androidx.activity.ComponentActivity
12	import androidx.lifecycle.lifecycleScope
13	import com.example.lb5.R
14	import kotlinx.coroutines.launch
15	
16	class SignInActivity : ComponentActivity() {
17	
18	    private lateinit var emailEditText: EditText
19	    private lateinit var passwordEditText: EditText
20	    private lateinit var signInButton: Button
21	    private lateinit var toSignUpButton: Button
22	    private lateinit var signInService: SignInService
23	    private lateinit var pref: MyPreferences
24	
25	    override fun onCreate(savedInstanceState: Bundle?) {
26	        super.onCreate(savedInstanceState)
27	        setContentView(R.layout.activity_sign_in)
28	
29	        signInService = SignInService(this)
30	
31	        emailEditText = findViewById(R.id.email)
32	        passwordEditText = findViewById(R.id.password)
33	        signInButton = findViewById(R.id.sign_in)
34	        toSignUpButton = findViewById(R.id.to_sign_up)
35	        pref = MyPreferences(this)
36	
37	        signInButton.setOnClickListener {
38	            val email = emailEditText.text.toString()
39	            val password = passwordEditText.text.toString()
40	
41	            lifecycleScope.launch {
42	                val success = signInService.signIn(email, password)
43	
44	                if (success) {
45	//                    Toast.makeText(this@SignInActivity, "You signed in", Toast.LENGTH_SHORT).show()
46	
47	                    val accessToken = pref.getValueStr("accessToken")
48	
49	                    Toast.makeText(this@SignInActivity, accessToken, Toast.LENGTH_SHORT).show()
50	
51	                    val intent = Intent(this@SignInActivity, ProfileActivity::class.java)
52	                    startActivity(intent)
53	                } else {
54	                    Toast.makeText(this@SignInActivity, "Some error occurred", Toast.LENGTH_SHORT).show()
55	                }
56	            }
57	        }
58	        
59	        toSignUpButton.setOnClickListener {
60	            val intent = Intent(this, SignUpActivity::class.java)
61	            startActivity(intent)
62	        }
63	    }
64	}


Д.2 Код файлу сервіса для входу в обліковий запис


1	import android.content.Context
2	import kotlinx.coroutines.Dispatchers
3	import kotlinx.coroutines.withContext
4	import java.net.HttpURLConnection
5	import java.net.URL
6	import java.net.URLEncoder
7	import java.nio.charset.StandardCharsets
8	import org.json.JSONObject
9	
10	class SignInService(private val context: Context) {
11	    private val PREFS_NAME = "com.myapp.preferences"
12	    private val ACCESS_TOKEN = "accessToken"
13	    private val sharedPref = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
14	
15	    suspend fun signIn(email: String, password: String): Boolean = withContext(Dispatchers.IO) {
16	        val url = URL("http://192.168.10.133:3000/api/auth/signin")
17	
18	        val postData = "email=${URLEncoder.encode(email, StandardCharsets.UTF_8.name())}&password=${URLEncoder.encode(password, StandardCharsets.UTF_8.name())}"
19	        val postDataBytes = postData.toByteArray(StandardCharsets.UTF_8)
20	
21	        val connection = url.openConnection() as HttpURLConnection
22	        connection.requestMethod = "POST"
23	        connection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded")
24	        connection.setRequestProperty("Content-Length", postDataBytes.size.toString())
25	        connection.doOutput = true
26	        connection.outputStream.write(postDataBytes)
27	
28	        val responseCode = connection.responseCode
29	        println("Response code: $responseCode")
30	
31	        return@withContext if (responseCode == HttpURLConnection.HTTP_CREATED) {
32	            val inputStream = connection.inputStream
33	            val content = inputStream.bufferedReader().use { it.readText() }
34	            println("Response content: $content")
35	
36	            val jsonObject = JSONObject(content)
37	            val accessToken = jsonObject.getString("accessToken")
38	        
39	            val editor = sharedPref.edit()
40	            editor.putString(ACCESS_TOKEN, accessToken)
41	            editor.apply()
42	
43	            true
44	        } else {
45	            false
46	        }
47	    }
48	}


Д.3 Код файлу сервіса для входу в обліковий запис


1	package com.example.lb5.profile.activities
2	
3	import MyPreferences
4	import android.content.Intent
5	import android.content.res.Configuration
6	import android.os.Bundle
7	import android.widget.Button
8	import android.widget.TextView
9	import androidx.activity.ComponentActivity
10	import com.example.lb5.R
11	import com.example.lb5.authorization.activities.SignInActivity
12	import com.example.lb5.document.activities.DocumentsActivity
13	import kotlinx.coroutines.CoroutineScope
14	import kotlinx.coroutines.Dispatchers
15	import kotlinx.coroutines.launch
16	import kotlinx.coroutines.withContext
17	import org.json.JSONObject
18	import java.net.HttpURLConnection
19	import java.net.URL
20	import java.util.Locale
21	
22	class ProfileActivity : ComponentActivity() {
23	
24	    private lateinit var emailTextView: TextView
25	    private lateinit var nicknameTextView: TextView
26	    private lateinit var updateProfileButton: Button
27	    private lateinit var logOutButton: Button
28	    private lateinit var documentsButton : Button
29	    private lateinit var pref: MyPreferences
30	    private lateinit var englishButton: Button
31	    private lateinit var ukrainianButton: Button
32	
33	    override fun onCreate(savedInstanceState: Bundle?) {
34	        super.onCreate(savedInstanceState)
35	        setContentView(R.layout.activity_profile)
36	
37	        emailTextView = findViewById(R.id.emailTextView)
38	        nicknameTextView = findViewById(R.id.nicknameTextView)
39	        updateProfileButton = findViewById(R.id.updateProfileButton)
40	        logOutButton = findViewById(R.id.logOutButton)
41	        documentsButton = findViewById(R.id.toDocumentsButton)
42	        pref = MyPreferences(this)
43	        englishButton = findViewById(R.id.english)
44	        ukrainianButton = findViewById(R.id.ukrainian)
45	
46	        CoroutineScope(Dispatchers.IO).launch {
47	            val profileUrl = URL("http://192.168.10.133:3000/api/profile")
48	            val profileConnection = profileUrl.openConnection() as HttpURLConnection
49	            profileConnection.requestMethod = "GET"
50	            profileConnection.setRequestProperty("Authorization", pref.getValueStr("accessToken"))
51	
52	            val inputStream = profileConnection.inputStream
53	            val content = inputStream.bufferedReader().use { it.readText() }
54	
55	            val profileJsonObject = JSONObject(content)
56	
57	            withContext(Dispatchers.Main) {
58	                emailTextView.text = profileJsonObject.getString("email")
59	                nicknameTextView.text = profileJsonObject.getString("nickname")
60	            }
61	        }
62	
63	        updateProfileButton.setOnClickListener {
64	            val intent = Intent(this, UpdateProfileActivity::class.java)
65	            startActivity(intent)
66	        }
67	
68	        logOutButton.setOnClickListener {
69	            pref.save("accessToken", "")
70	
71	            val intent = Intent(this, SignInActivity::class.java)
72	            startActivity(intent)
73	        }
74	
75	        documentsButton.setOnClickListener {
76	            val intent = Intent(this, DocumentsActivity::class.java)
77	            startActivity(intent)
78	        }
79	
80	        englishButton.setOnClickListener {
81	            val locale = Locale("en")
82	            Locale.setDefault(locale)
83	            val config = Configuration()
84	            config.locale = locale
85	            baseContext.resources.updateConfiguration(config, baseContext.resources.displayMetrics)
86	            recreate()
87	        }
88	
89	        ukrainianButton.setOnClickListener {
90	            val locale = Locale("uk")
91	            Locale.setDefault(locale)
92	            val config = Configuration()
93	            config.locale = locale
94	            baseContext.resources.updateConfiguration(config, baseContext.resources.displayMetrics)
95	            recreate()
96	        }
97	    }
98	}


Д.4 Код файлу сервіса для входу в обліковий запис


1	<?xml version="1.0" encoding="utf-8"?>
2	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
3	    android:layout_width="match_parent"
4	    android:layout_height="match_parent"
5	    android:orientation="vertical"
6	    android:padding="16dp">
7	
8	    <TextView
9	        android:id="@+id/emailTextView"
10	        android:layout_width="match_parent"
11	        android:layout_height="wrap_content"
12	        android:text="@string/email"
13	        android:textSize="16sp" />
14	
15	    <TextView
16	        android:id="@+id/nicknameTextView"
17	        android:layout_width="match_parent"
18	        android:layout_height="wrap_content"
19	        android:text="@string/nickname"
20	        android:textSize="16sp"
21	        android:layout_marginTop="16dp" />
22	
23	    <Button
24	        android:id="@+id/updateProfileButton"
25	        android:layout_width="match_parent"
26	        android:layout_height="wrap_content"
27	        android:text="@string/update_profile"
28	        android:layout_marginTop="16dp" />
29	
30	    <Button
31	        android:id="@+id/logOutButton"
32	        android:layout_width="match_parent"
33	        android:layout_height="wrap_content"
34	        android:text="@string/log_out"
35	        android:layout_marginTop="16dp" />
36	
37	    <Button
38	        android:id="@+id/toDocumentsButton"
39	        android:layout_width="match_parent"
40	        android:layout_height="wrap_content"
41	        android:text="@string/your_documents"
42	        android:layout_marginTop="16dp" />
43	
44	    <Button
45	        android:id="@+id/english"
46	        android:layout_width="match_parent"
47	        android:layout_height="wrap_content"
48	        android:text="English"
49	        android:layout_marginTop="16dp" />
50	
51	    <Button
52	        android:id="@+id/ukrainian"
53	        android:layout_width="match_parent"
54	        android:layout_height="wrap_content"
55	        android:text="Ukrainian"
56	        android:layout_marginTop="16dp" />
57	
58	</LinearLayout>
